#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "mpi.h"



struct data_struct{
  long int num;
  long double xyz[3];
};

int main(int argc, char* argv[]){ 
  
  int num;
  FILE *fp;
  int i, j, total=0, K=0, colIndex =0;
  int num_ranks;
  int my_rank;
  int* send_counts;
  int * send_displs;
  int* recv_displs;
  int* recv_counts;
  int* rank_counts;
  int total_recv_counts;
  struct data_struct temp;
  int rank_to_print = 2;  // Change to 0, 1 or 2
  
  if (argc != 3){
    printf("Needs two argument and to be run with 2 cores.\nUsage <mpirun -n 2 test \"num\" infile>\nExiting now\n");
    exit(0);
  }

  // Number of elements to work on
  num = atoi(argv[1]);

  // declare array of struct
  struct data_struct* array  = (struct data_struct *) malloc(num * sizeof(struct data_struct));
  


  //Read in file and store in array
  i = 0;
  if ((fp = fopen(argv[2], "rb")) != NULL){
    while(!feof(fp) && i < num){
      fread(&temp.num, sizeof(long int), 1, fp);
      fread(&temp.xyz[0], sizeof(long double), 1, fp); 
      fread(&temp.xyz[1], sizeof(long double), 1, fp); 
      fread(&temp.xyz[2], sizeof(long double), 1, fp); 
      array[i++] = temp;
    }
    fclose(fp);
  }

  
  MPI_Init(&argc, &argv);
  MPI_Comm_size(MPI_COMM_WORLD, &num_ranks);
  MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
     
  MPI_Status status;
  MPI_Datatype array_type, data_type[2];
  int data_length[2];
  MPI_Aint displ[2], lower_bound, extent;
 
  
  // Describe the MPI_LONG_INT field in the struct
  displ[0] = 0;
  data_type[0] = MPI_LONG_INT;
  data_length[0] = 1;    
  
  //Describe the MPI_LONG_DOUBLE in the field.
  //Obtain offset using size of MPI_LONG_INT already described
  MPI_Type_get_extent(MPI_LONG_INT, &lower_bound, &extent);
  displ[1] = data_length[0] * extent;
  data_type[1] = MPI_LONG_DOUBLE;
  data_length[1] = 3;
  
  
  // Define the new data_type of our struct and commit
  MPI_Type_create_struct(2, data_length, displ, data_type, &array_type);
  MPI_Type_commit(&array_type);
  
  
    // Change all my array entries as defined below
    for (i = 0; i < num; i++){
      array[i].xyz[0] = my_rank;
      array[i].xyz[1] = my_rank;;
      array[i].xyz[2] = my_rank;
    }

    // Allocate arrays for use with the Alltoallv command
    rank_counts = (int *) calloc(num_ranks*num_ranks, sizeof(int));
    send_counts = (int *) calloc(num_ranks, sizeof(int));
    recv_counts = (int *) calloc(num_ranks, sizeof(int));
    recv_displs = (int *) calloc(num_ranks, sizeof(int));
    send_displs = (int *) calloc(num_ranks, sizeof(int));

    
    // The next line will be generated by an Allgather from all ranks in the main code
    // Restricted to using 3 processes bcos of the hard-code below
    rank_counts[0] = 50;
    rank_counts[1] = 30;   //      Send_counts/recv_counts
    rank_counts[2] = 20;   // Ranks   0   1   2
    rank_counts[3] = 25;   //     0   50  30  20 
    rank_counts[4] = 60;   //     1   25  60  15
    rank_counts[5] = 15;   //     2   25  10  65
    rank_counts[6] = 25;
    rank_counts[7] = 10;
    rank_counts[8] = 65;
    

    // Set the amount to send and recieve from all processes.
    send_counts[0] = rank_counts[num_ranks*my_rank];
    total_recv_counts =  recv_counts[0] = rank_counts[my_rank];
    for (i=1; i < num_ranks; i++){
      send_counts[i] = rank_counts[num_ranks*my_rank + i];
      send_displs[i] = send_displs[i-1] + send_counts[i-1];
      recv_counts[i] = rank_counts[i*num_ranks + my_rank];
      recv_displs[i] = recv_displs[i-1] + recv_counts[i-1];
      total_recv_counts += recv_counts[i];
    }

    /*
    for (i = 0; i < num_ranks; i++){
      printf("rank %d: \tsend_counts[%d] = %d\n", my_rank, i, send_counts[i]);
      printf("rank %d: \trecv_counts[%d] = %d\n", my_rank, i, recv_counts[i]);
      printf("rank %d: \trecv_displs[%d] = %d\n", my_rank, i, recv_displs[i]);
      printf("rank %d: \tsend_displs[%d] = %d\n", my_rank, i, send_displs[i]);
      }*/

    if (my_rank == rank_to_print){
      printf("\n\n\n");
      printf("\nArray before Alltoallv\n");
      printf("\n\n\n");
      for (i = 0; i < num; i++)
	printf("%Lu\t%0.15Lf\t%0.15Lf\t%0.15Lf\n", array[i].num, array[i].xyz[0], array[i].xyz[1], array[i].xyz[2]);
    }
    

    // Create a new array of size total_recv_counts
    struct data_struct* recv_array  = (struct data_struct *) malloc(total_recv_counts * sizeof(struct data_struct));
    
    MPI_Alltoallv(array, send_counts, send_displs, array_type, recv_array, recv_counts, recv_displs, array_type, MPI_COMM_WORLD);
    
      
    if (my_rank == rank_to_print){
      printf("\n\n\n");
      printf("\nArray after Alltoallv\n");
      printf("\n\n\n");
      for (i = 0; i < num; i++){
	recv_array[i].num = i+1; //Intentionally reordering the index to be sequential
	printf("%Lu\t%0.15Lf\t%0.15Lf\t%0.15Lf\n", recv_array[i].num, recv_array[i].xyz[0], recv_array[i].xyz[1], recv_array[i].xyz[2]);
      }
    }
        
  MPI_Type_free(&array_type);
  free(array);
  MPI_Finalize();
}
